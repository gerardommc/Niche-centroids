vec = rep(NA, max(ref.lines)*max(ref.cols)) # A vector with the length of data points
ref.vec = (ref.cols - 1)*max(ref.lines) + ref.lines
vec[ref.vec] = 1
data.mask = matrix(vec, max(ref.lines), max(ref.cols), dimnames = list(uy, ux))
win = as.owin(im(data.mask, xcol = ux, yrow = uy)) #Data analysis window
## transforming species points to a planar point pattern
spp.ppp <- lapply(spp.points, function(x){
ppp(x[, 'x'], x[, 'y'], window = win, check = F)
})
## Transforming species' layers to spatstat images
spp.lay.im <- lapply(spp.lay.df, function(x){
require(foreach)
names(x) <- c("x", "y", "a", "b", "c")
X <- with(x, cbind(a, b, c))
lay.im.list <- foreach(i = 1:ncol(X)) %do% {
vec.all = rep(NA, max(ref.lines)*max(ref.cols))
vec.ref = (ref.cols - 1)*max(ref.lines) + ref.lines
vec.all[ref.vec] = X[,i]
lay <- im(matrix(vec.all, max(ref.lines), max(ref.cols),
dimnames = list(uy, ux)), xcol = ux, yrow = uy)
return(lay)
}
names(lay.im.list) <- c("a", "b", "c")
return(lay.im.list)
})
## Fitting ppms
spp.ppms <- lapply(seq_along(spp.ppp), function(i){
ppm.mod <-ppm(spp.ppp[[i]],
trend = ~ a + b + c +
I(a^2) + I(b^2) + I(c^2),
covariates = spp.lay.im[[i]])
return(ppm.mod)
})
warnings()
for(i in seq_along(spp.ppms)){
saveRDS(spp.ppms[[i]], paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-", i, ".rds"))
}
library(raster); library(doParallel); library(spatstat)
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
spp.layers <- lapply(1:ncol(config$layers), function(x){dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config$layers[, x])))})
spp.points <- readRDS("Simulated-species/Species-presences.rds")
p.spp <- readRDS("Simulated-species/P-presence.rds")
spp.cent.cov <- readRDS("Simulated-species/Spp-cent-covs.rds")
spp.ppms <- lapply(1:1000, function(x){
readRDS(paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-", x, ".rds"))
})
spp.lay.df <- lapply(spp.layers, function(x){data.frame(rasterToPoints(x))}) #Transform layers to dataframes
spp.point.vals <- lapply(seq_along(spp.layers), function(x){extract(spp.layers[[x]], spp.points[[x]])}) #Extracting values at points
## Coercing raster package data to spatstat
ux = sort(unique(spp.lay.df[[1]]$x)) #Extracting unique coordinates
uy = sort(unique(spp.lay.df[[1]]$y))
nx = length(ux) #length of unique coordinates
ny = length(uy)
ref.cols = match(spp.lay.df[[1]]$x, ux) #position of every data point
ref.lines = match(spp.lay.df[[1]]$y, uy)
vec = rep(NA, max(ref.lines)*max(ref.cols)) # A vector with the length of data points
ref.vec = (ref.cols - 1)*max(ref.lines) + ref.lines
vec[ref.vec] = 1
data.mask = matrix(vec, max(ref.lines), max(ref.cols), dimnames = list(uy, ux))
win = as.owin(im(data.mask, xcol = ux, yrow = uy)) #Data analysis window
## transforming species points to a planar point pattern
spp.ppp <- lapply(spp.points, function(x){
ppp(x[, 'x'], x[, 'y'], window = win, check = F)
})
## Transforming species' layers to spatstat images
spp.lay.im <- lapply(spp.lay.df, function(x){
require(foreach)
names(x) <- c("x", "y", "a", "b", "c")
X <- with(x, cbind(a, b, c))
lay.im.list <- foreach(i = 1:ncol(X)) %do% {
vec.all = rep(NA, max(ref.lines)*max(ref.cols))
vec.ref = (ref.cols - 1)*max(ref.lines) + ref.lines
vec.all[ref.vec] = X[,i]
lay <- im(matrix(vec.all, max(ref.lines), max(ref.cols),
dimnames = list(uy, ux)), xcol = ux, yrow = uy)
return(lay)
}
names(lay.im.list) <- c("a", "b", "c")
return(lay.im.list)
})
ppm.preds <- lapply(seq_along(spp.ppms), function(x){
raster(predict(spp.ppms[[x]], type = "trend", ngrid = c(100, 100)))
})
cor.ppm.preds <- lapply(1:1000, function(x){cor.test(ppm.preds[[x]][], p.spp[[x]][])})
corr.estimates <- sapply(cor.ppm.preds, function(x){x$estimate})
centroids <- lapply(spp.ppms, function(x){
effects <- x$coef[2:7]
cent.a <- - effects[1]/(2 * effects[4])
cent.b <- - effects[2]/(2 * effects[5])
cent.c <- - effects[3]/(2 * effects[6])
centroid <- c(a = cent.a,
b = cent.b,
c = cent.c)
return(centroid)
})
dist.true.cents <- sapply(seq_along(centroids), function(x){
mahalanobis(centroids[[x]], spp.cent.cov$centroids[[x]], spp.cent.cov$covariances[[x]])
})
df.centroids <- data.frame(Corr.surf = corr.estimates, Dist.true.cent = dist.true.cents)
vars.spp <- foreach(i = seq_along(config$layer.names), .combine = rbind) %do% {
vars <- sapply(c("mean", "Log", "Beta", "Gamma"), function(x){
grep(pattern = x, config$layer.names[[i]])
})
return(sapply(vars, length))
}
vars.spp <- data.frame(vars.spp)
names(vars.spp) <- c("Normal", "Log.norm", "Beta", "Gamma")
df.results <- data.frame(df.centroids, vars.spp, approach = "PPM")
write.csv(df.results, "Simulated-species/Results-PPMs.csv", row.names = F)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
ppms <- read.csv("Simulated-species/Results-PPMs.csv")
ellips <- read.csv("Simulated-species/Results-ellipses.csv")
mod.ellips <- read.csv("Simulated-species/Results-mod-ellipses.csv")
all.results <- rbind(ppms, ellips, mod.ellips)
ggplot(all.results) + geom_violin(aes(x = approach, y = Corr.surf)) +
geom_boxplot(aes(x = approach, y = Corr.surf), alpha = 0.5) +
labs(x = "Approach", y = "Correlation with generating surface")
ggplot(all.results) + geom_point(aes(x = log10(Dist.true.cent), y = Corr.surf, colour = approach), alpha = 0.1) +
geom_smooth(aes(x = log10(Dist.true.cent), y = Corr.surf, colour = approach, fill = approach), alpha = 0.5) +
labs(x = "log-Distance to true centroid", y = "Correlation with generating surface",
colour = "Approach", fill = "Approach")
corr.dif <- ppms$Corr.surf - ellips$Corr.surf
dist.dif <- ppms$Dist.true.cent - ellips$Dist.true.cent
p.cor <- length(which(corr.dif >0))/length(corr.dif)
p.dif <- length(which(dist.dif > 0))/length(dist.dif)
p.cor/(1-p.cor)
p.dif/(1-p.dif)
ellip.best <- which.min(ellips$Dist.true.cent)
ppm.best <- which.min(ppms$Dist.true.cent)
ellip.worst <- which.max(ellips$Dist.true.cent)
ppm.worst <- which.max(ppms$Dist.true.cent)
ellips[ellip.best,]
ellips[ellip.best,]
ppms[ppm.best, ]
ellip.worst
ppm.worst
ellips[ellip.worst,]
ppms[ppm.worst, ]
library(spatstat); library(ntbox)
ppm.best.mod <- readRDS(paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-",ppm.best,".rds"))
ppm.worst.mod <- readRDS(paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-",ppm.worst,".rds"))
ellip.best.mod <- readRDS(paste0("../Resultados/Analysis-centroids/Fitted-ellipses/Ellips-",ellip.best,".rds"))
ellip.worst.mod <- readRDS(paste0("../Resultados/Analysis-centroids/Fitted-mod-ellipses/Mod-ellips-",ellip.worst,".rds"))
coef(ppm.worst.mod)
coef(ppm.best.mod)
all.ppms <- lapply(paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-", 1:1000,".rds"), readRDS)
neg.coefs <- sapply(all.ppms, function(x){(any(x$coef[5:7] > 0))})
ppms$pos.neg <- neg.coefs
ggplot(ppms) + geom_violin(aes(x = pos.neg, y = log10(Dist.true.cent))) +
geom_boxplot(aes(x = pos.neg, y = log10(Dist.true.cent)), alpha = 0.5) +
labs(x = "Positive cofficients in model", y = "log10 distance to true centroid")
library(raster)
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
lay.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
lay.gen.worst <- dropLayer(layers, which(! 1:100 %in% config$combinations[,config$sample[ellip.worst]] ))
par(mfrow = c(3, 2))
for(i in 1:3){
plot(lay.gen.worst[[i]], main = c("Normal", "Log-normal", "Gamma")[i])
density(lay.gen.worst[[i]], xlab = "Value", ylab = "Frequency")
abline(v = lay.sum$means[config$combinations[, config$sample[ellip.worst]][i]])
abline(v = ellip.worst.mod[[1]]$center[i], col = "red")
}
p.pres <- readRDS("Simulated-species/P-presence.rds")
occurs <- readRDS("Simulated-species/Species-presences.rds")
par(mfrow = c(3,1))
plot(p.pres[[ellip.worst]], main = "Generating surface")
plot(ellip.worst.mod[[2]]$suitRaster, main = "Distance to estimated centroid")
plot(ellip.worst.mod[[2]]$suitRaster[], p.pres[[ellip.worst]][],
xlab = "DNC", ylab = "Gen surface")
p.pres <- readRDS("Simulated-species/P-presence.rds")
occurs <- readRDS("Simulated-species/Species-presences.rds")
par(mfrow = c(3,1))
plot(p.pres[[ellip.worst]], main = "Generating surface")
plot(log(ellip.worst.mod[[2]]$suitRaster), main = "Distance to estimated centroid")
plot(ellip.worst.mod[[2]]$suitRaster[], p.pres[[ellip.worst]][],
xlab = "DNC", ylab = "Gen surface")
p.pres <- readRDS("Simulated-species/P-presence.rds")
occurs <- readRDS("Simulated-species/Species-presences.rds")
par(mfrow = c(3,1))
plot(p.pres[[ellip.worst]], main = "Generating surface")
plot(ellip.worst.mod[[2]]$suitRaster, main = "Distance to estimated centroid")
plot(ellip.worst.mod[[2]]$suitRaster[], p.pres[[ellip.worst]][],
xlab = "DNC", ylab = "Gen surface")
l <- readRDS("Simulated-layers/All-simulated-layers.rds")
length(l)
class(l)
nlayers(l)
names(l)
for(i in 1:100) plot(l[[i]], main = names(l))
for(i in 1:100) plot(l[[i]], main = names(l)[i])
for(i in 1:100){
par(mfrow = c(1, 2))
plot(l[[i]], main = names(l)[i])
density(l[[i]])}
for(i in 1:100){
par(mfrow = c(1, 2))
plot(l[[i]], main = names(l)[i])
density(l[[i]])
abline(v = cellStats(l[[i]], mean), col = "red")
}
plot(l[[1]] - l[[10]])
density(l[[1]] - l[[10]])
density(l[[1]] - l[[50]])
density(l[[1]] -*l[[50]])
density(l[[1]]*l[[50]])
density(l[[1]]*l[[75]])
plot(l[[1]] * l[[75]])
plot(l[[1]] * l[[75]])
density(l[[1]]*l[[75]])
plot(l[[75]])
plot(l[[1]])
plot(l[[75]])
plot(l[[75]])
plot(l[[1]])
library(raster)
detach("package:raster", unload = TRUE)
library(raster); library(doParallel); library(spatstat)
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
spp.layers <- lapply(1:ncol(config$layers), function(x){dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config$layers[, x])))})
spp.points <- readRDS("Simulated-species/Species-presences.rds")
p.spp <- readRDS("Simulated-species/P-presence.rds")
spp.cent.cov <- readRDS("Simulated-species/Spp-cent-covs.rds")
### Formatting data for spatstat
spp.lay.df <- lapply(spp.layers, function(x){data.frame(rasterToPoints(x))}) #Transform layers to dataframes
spp.point.vals <- lapply(seq_along(spp.layers), function(x){extract(spp.layers[[x]], spp.points[[x]])}) #Extracting values at points
## Coercing raster package data to spatstat
ux = sort(unique(spp.lay.df[[1]]$x)) #Extracting unique coordinates
uy = sort(unique(spp.lay.df[[1]]$y))
nx = length(ux) #length of unique coordinates
ny = length(uy)
ref.cols = match(spp.lay.df[[1]]$x, ux) #position of every data point
ref.lines = match(spp.lay.df[[1]]$y, uy)
vec = rep(NA, max(ref.lines)*max(ref.cols)) # A vector with the length of data points
ref.vec = (ref.cols - 1)*max(ref.lines) + ref.lines
vec[ref.vec] = 1
data.mask = matrix(vec, max(ref.lines), max(ref.cols), dimnames = list(uy, ux))
win = as.owin(im(data.mask, xcol = ux, yrow = uy)) #Data analysis window
## transforming species points to a planar point pattern
spp.ppp <- lapply(spp.points, function(x){
ppp(x[, 'x'], x[, 'y'], window = win, check = F)
})
## Transforming species' layers to spatstat images
spp.lay.im <- lapply(spp.lay.df, function(x){
require(foreach)
names(x) <- c("x", "y", "a", "b", "c")
X <- with(x, cbind(a, b, c))
lay.im.list <- foreach(i = 1:ncol(X)) %do% {
vec.all = rep(NA, max(ref.lines)*max(ref.cols))
vec.ref = (ref.cols - 1)*max(ref.lines) + ref.lines
vec.all[ref.vec] = X[,i]
lay <- im(matrix(vec.all, max(ref.lines), max(ref.cols),
dimnames = list(uy, ux)), xcol = ux, yrow = uy)
return(lay)
}
names(lay.im.list) <- c("a", "b", "c")
return(lay.im.list)
})
## Fitting ppms
spp.ppms <- lapply(seq_along(spp.ppp), function(i){
ppm.mod <-ppm(spp.ppp[[i]],
trend = ~ a + b + c +
I(a^2) + I(b^2) + I(c^2),
covariates = spp.lay.im[[i]])
return(ppm.mod)
})
dir.create("../Resultados/Analysis-centroids/Fitted-PPMs")
for(i in seq_along(spp.ppms)){
saveRDS(spp.ppms[[i]], paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-", i, ".rds"))
}
library(raster); library(doParallel); library(spatstat)
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
spp.layers <- lapply(1:ncol(config$layers), function(x){dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config$layers[, x])))})
spp.points <- readRDS("Simulated-species/Species-presences.rds")
p.spp <- readRDS("Simulated-species/P-presence.rds")
spp.cent.cov <- readRDS("Simulated-species/Spp-cent-covs.rds")
spp.ppms <- lapply(1:1000, function(x){
readRDS(paste0("../Resultados/Analysis-centroids/Fitted-PPMs/PPM-", x, ".rds"))
})
### Formatting data for spatstat
spp.lay.df <- lapply(spp.layers, function(x){data.frame(rasterToPoints(x))}) #Transform layers to dataframes
spp.point.vals <- lapply(seq_along(spp.layers), function(x){extract(spp.layers[[x]], spp.points[[x]])}) #Extracting values at points
## Coercing raster package data to spatstat
ux = sort(unique(spp.lay.df[[1]]$x)) #Extracting unique coordinates
uy = sort(unique(spp.lay.df[[1]]$y))
nx = length(ux) #length of unique coordinates
ny = length(uy)
ref.cols = match(spp.lay.df[[1]]$x, ux) #position of every data point
ref.lines = match(spp.lay.df[[1]]$y, uy)
vec = rep(NA, max(ref.lines)*max(ref.cols)) # A vector with the length of data points
ref.vec = (ref.cols - 1)*max(ref.lines) + ref.lines
vec[ref.vec] = 1
data.mask = matrix(vec, max(ref.lines), max(ref.cols), dimnames = list(uy, ux))
win = as.owin(im(data.mask, xcol = ux, yrow = uy)) #Data analysis window
## transforming species points to a planar point pattern
spp.ppp <- lapply(spp.points, function(x){
ppp(x[, 'x'], x[, 'y'], window = win, check = F)
})
## Transforming species' layers to spatstat images
spp.lay.im <- lapply(spp.lay.df, function(x){
require(foreach)
names(x) <- c("x", "y", "a", "b", "c")
X <- with(x, cbind(a, b, c))
lay.im.list <- foreach(i = 1:ncol(X)) %do% {
vec.all = rep(NA, max(ref.lines)*max(ref.cols))
vec.ref = (ref.cols - 1)*max(ref.lines) + ref.lines
vec.all[ref.vec] = X[,i]
lay <- im(matrix(vec.all, max(ref.lines), max(ref.cols),
dimnames = list(uy, ux)), xcol = ux, yrow = uy)
return(lay)
}
names(lay.im.list) <- c("a", "b", "c")
return(lay.im.list)
})
ppm.preds <- lapply(seq_along(spp.ppms), function(x){
raster(predict(spp.ppms[[x]], type = "trend", ngrid = c(100, 100)))
})
cor.ppm.preds <- lapply(1:1000, function(x){cor.test(ppm.preds[[x]][], p.spp[[x]][])})
corr.estimates <- sapply(cor.ppm.preds, function(x){x$estimate})
## Computing centroids
centroids <- lapply(spp.ppms, function(x){
effects <- x$coef[2:7]
cent.a <- - effects[1]/(2 * effects[4])
cent.b <- - effects[2]/(2 * effects[5])
cent.c <- - effects[3]/(2 * effects[6])
centroid <- c(a = cent.a,
b = cent.b,
c = cent.c)
return(centroid)
})
#Calculating the distance to true centroids
dist.true.cents <- sapply(seq_along(centroids), function(x){
mahalanobis(centroids[[x]], spp.cent.cov$centroids[[x]], spp.cent.cov$covariances[[x]])
})
#Saving results
df.centroids <- data.frame(Corr.surf = corr.estimates, Dist.true.cent = dist.true.cents)
vars.spp <- foreach(i = seq_along(config$layer.names), .combine = rbind) %do% {
vars <- sapply(c("mean", "Log", "Beta", "Gamma"), function(x){
grep(pattern = x, config$layer.names[[i]])
})
return(sapply(vars, length))
}
vars.spp <- data.frame(vars.spp)
names(vars.spp) <- c("Normal", "Log.norm", "Beta", "Gamma")
df.results <- data.frame(df.centroids, vars.spp, approach = "PPM")
write.csv(df.results, "Simulated-species/Results-PPMs.csv", row.names = F)
library(raster)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv", stringsAsFactors = F)
total.combinations <- combn(x = 100, m = 3)
s <- sample(1:ncol(total.combinations), 1000)
sample.layers <- total.combinations[, s]
layer.names <- lapply(1:ncol(sample.layers), function(x){l.sum$Layer.name[sample.layers[, x]]})
species.config.list <- list(Readme = "This list containes three other objects \n
1- The total possible number of three layer combinations out of
the 100 simulated layers. \n
2- An index of the random sample of the entire number of combinations and \n
3- The matrix of combinations \n
4- The names of each layer in the combination",
combinations = total.combinations,
sample = s,
layers = sample.layers,
layer.names = layer.names)
dir.create("Simulated-species")
saveRDS(species.config.list, "Simulated-species/Sim-config-species-list-RandomCentroids.rds")
####
species.layers <- lapply(1:ncol(sample.layers), function(x){dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% sample.layers[, x])))})
plot(species.layers[[1]])
species.layers[[1]][]
samp <- sample(1:10000, size = 3, replace = T)
species.layers[[1]][samp, 1:3]
samp
x <- species.layers[[1]]
samp <- sample(1:10000, size = 3, replace = T)
cent <- c(x[samp[1], 1],
x[samp[2], 2],
x[samp[3], 3])
cent
x[samp[1], 1]
class(x[])
nrow(x[])
cent <- c(x[][samp[1], 1],
x[][samp[2], 2],
x[][samp[3], 3])
cent
species.centroids <- lapply(species.layers,
function(x){
samp <- sample(1:10000, size = 3, replace = T)
cent <- c(x[][samp[1], 1],
x[][samp[2], 2],
x[][samp[3], 3])
})
species.covariances <- lapply(1:ncol(sample.layers), function(x){
df <- data.frame(rasterToPoints(species.layers[[x]]))[, 3:5]
return(MASS :: cov.rob(df, method = "mve", nsamp = "sample", seed = 1234)$cov)})
warnings()
spp.cent.cov <- list(centroids = species.centroids,
covariances = species.covariances)
saveRDS(spp.cent.cov, "Simulated-species/Spp-cent-covs-RandomCentroids.rds")
mahal.dists <- lapply(1:ncol(sample.layers), function(x){
df <- data.frame(rasterToPoints(species.layers[[x]]))
dist <- mahalanobis(df[, 3:5], center = species.centroids[[x]], cov = species.covariances[[x]])
dist <- round(dist, 3)
r <- rasterFromXYZ(data.frame(df[, c("x", "y")], dist))
return(r)
})
plot(mahal.dists[[1]])
plot(mahal.dists[[100]])
plot(mahal.dists[[350]])
plot(mahal.dists[[450]])
plot(mahal.dists[[900]])
plot(mahal.dists[[9800]])
plot(mahal.dists[[800]])
p.presence <- lapply(mahal.dists, function(x){exp(-0.5 * x)})
saveRDS(mahal.dists, "Simulated-species/Mahal-dists-RandomCentroids.rds")
saveRDS(p.presence, "Simulated-species/P-presence-RandomCentroids.rds")
plot(p.presence[[1]])
plot(p.presence[[100]])
plot(p.presence[[350]])
plot(p.presence[[900]])
plot(p.presence[[800]])
library(dismo)
spp.points <- lapply(p.presence, function(x){
points <- randomPoints(mask = x, n = 500, prob = T)
points <- t(apply(points, 1, function(x){ x + rnorm(2)}))
return(points)
})
saveRDS(spp.points, "Simulated-species/Species-presences-RandomCentroids.rds")
library(raster)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv", stringsAsFactors = F)
total.combinations <- combn(x = 100, m = 3)
s <- sample(1:ncol(total.combinations), 1000)
sample.layers <- total.combinations[, s]
layer.names <- lapply(1:ncol(sample.layers), function(x){l.sum$Layer.name[sample.layers[, x]]})
species.config.list <- list(Readme = "This list containes three other objects \n
1- The total possible number of three layer combinations out of
the 100 simulated layers. \n
2- An index of the random sample of the entire number of combinations and \n
3- The matrix of combinations \n
4- The names of each layer in the combination",
combinations = total.combinations,
sample = s,
layers = sample.layers,
layer.names = layer.names)
dir.create("Simulated-species")
saveRDS(species.config.list, "Simulated-species/Sim-config-species-list-EdgeCentroids.rds")
####
species.layers <- lapply(1:ncol(sample.layers), function(x){dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% sample.layers[, x])))})
x <- species.layers[[1]]
q <- sample(c(0.05, 0.95), 3, replace = T)
q
cent <- quantile(x, q)
cent
cent <- sapply(1:3, function(x1){quantile(x[[x1]], q[x1])})
cent
names(cent)
paste0(names(x), "-", names(cent))
species.centroids <- lapply(species.layers,
function(x){
q <- sample(c(0.05, 0.95), 3, replace = T)
cent <- sapply(1:3, function(x1){quantile(x[[x1]], q[x1])})
names(cent) <- paste0(names(x), "-", names(cent))
return(cent)
})
species.covariances <- lapply(1:ncol(sample.layers), function(x){
df <- data.frame(rasterToPoints(species.layers[[x]]))[, 3:5]
return(MASS :: cov.rob(df, method = "mve", nsamp = "sample", seed = 1234)$cov)})
spp.cent.cov <- list(centroids = species.centroids,
covariances = species.covariances)
saveRDS(spp.cent.cov, "Simulated-species/Spp-cent-covs-EdgeCentroids.rds")
mahal.dists <- lapply(1:ncol(sample.layers), function(x){
df <- data.frame(rasterToPoints(species.layers[[x]]))
dist <- mahalanobis(df[, 3:5], center = species.centroids[[x]], cov = species.covariances[[x]])
dist <- round(dist, 3)
r <- rasterFromXYZ(data.frame(df[, c("x", "y")], dist))
return(r)
})
saveRDS(mahal.dists, "Simulated-species/Mahal-dists-EdgeCentroids.rds")
p.presence <- lapply(mahal.dists, function(x){exp(-0.5 * x)})
saveRDS(p.presence, "Simulated-species/P-presence-EdgeCentroids.rds")
library(dismo)
spp.points <- lapply(p.presence, function(x){
points <- randomPoints(mask = x, n = 500, prob = T)
points <- t(apply(points, 1, function(x){ x + rnorm(2)}))
return(points)
})
saveRDS(spp.points, "Simulated-species/Species-presences-EdgeCentroids.rds")
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv", stringsAsFactors = F)
total.combinations <- combn(x = 100, m = 3)
s <- sample(1:ncol(total.combinations), 1000)
sample.layers <- total.combinations[, s]
layer.names <- lapply(1:ncol(sample.layers), function(x){l.sum$Layer.name[sample.layers[, x]]})
species.config.list <- list(Readme = "This list containes three other objects \n
1- The total possible number of three layer combinations out of
the 100 simulated layers. \n
2- An index of the random sample of the entire number of combinations and \n
3- The matrix of combinations \n
4- The names of each layer in the combination",
combinations = total.combinations,
sample = s,
layers = sample.layers,
layer.names = layer.names)
dir.create("Simulated-species")
