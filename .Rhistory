win = as.owin(im(data.mask, xcol = ux, yrow = uy)) #Data analysis window
## transforming species points to a planar point pattern
spp.ppp <- lapply(spp.points, function(x){
ppp(x[, 'x'], x[, 'y'], window = win, check = F)
})
## Transforming species' layers to spatstat images
spp.lay.im <- lapply(spp.lay.df, function(x){
require(foreach)
names(x) <- c("x", "y", "a", "b", "c")
X <- with(x, cbind(a, b, c))
lay.im.list <- foreach(i = 1:ncol(X)) %do% {
vec.all = rep(NA, max(ref.lines)*max(ref.cols))
vec.ref = (ref.cols - 1)*max(ref.lines) + ref.lines
vec.all[ref.vec] = X[,i]
lay <- im(matrix(vec.all, max(ref.lines), max(ref.cols),
dimnames = list(uy, ux)), xcol = ux, yrow = uy)
return(lay)
}
names(lay.im.list) <- c("a", "b", "c")
return(lay.im.list)
})
## Fitting ppms
spp.ppms <- lapply(seq_along(spp.ppp), function(i){
ppm.mod <-ppm(spp.ppp[[i]],
trend = ~ a + b + c +
I(a^2) + I(b^2) + I(c^2),
covariates = spp.lay.im[[i]])
coef <- coefficients(ppm.mod)
rast <- raster(predict(ppm.mod, type = "trend", ngrid = c(100, 100)))
return(list(pred = rast,
coef = coef))
})
warnings()
dir.create("../Resultados/Analysis-centroids/Fitted-Centre-Saturated-PPMs-NORM")
for(i in seq_along(spp.ppms)){
saveRDS(spp.ppms[[i]], paste0("../Resultados/Analysis-centroids/Fitted-Centre-Saturated-PPMs-NORM/PPM-", i, ".rds"))
}
library(raster); library(ntbox); library(doParallel); library(bestNormalize)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
spp.points <- readRDS("Simulated-species/Species-presences.rds")
p.spp <- readRDS("Simulated-species/P-presence.rds")
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
ellips <- lapply(1:2500, function(x){
readRDS(paste0("../Resultados/Analysis-centroids/Fitted-ellipses-NORM/Ellips-", x, ".rds"))
})
#Normalising the layers in order to transform the original centroids
registerDoParallel(cores = 8)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
n <- bestNormalize(df)
df.t <- predict(n)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(list(normLayer = r, normMod = n))
}
library(raster); library(ntbox); library(doParallel); library(bestNormalize)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
spp.points <- readRDS("Simulated-species/Species-presences.rds")
p.spp <- readRDS("Simulated-species/P-presence.rds")
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
ellips <- lapply(1:2500, function(x){
readRDS(paste0("../Resultados/Analysis-centroids/Fitted-ellipses-NORM/Ellips-", x, ".rds"))
})
#Normalising the layers in order to transform the original centroids
registerDoParallel(cores = 8)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
n <- bestNormalize(df)
df.t <- predict(n)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(list(normLayer = r, normMod = n))
}
normMods <- sapply(all.layers.norm, function(x){x$normMod})
all.layers.norm <- lapply(all.layers.norm, function(x){x$normLayer})
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
#####
spp.layers <- lapply(1:ncol(config$layers), function(x){dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config$layers[, x])))})
spp.cent.cov <- readRDS("Simulated-species/Spp-cent-covs.rds")
spp.cent.cov
spp.cent.cov[[1]]
spp.cent.cov$centroids
centroids <- spp.cent.cov$centroids
ellips[[1]]
covariances <- lapply(ellips, function(x){x$covariance})
covariances
ellips[[1]][[1]]$covariance
ellips[[1]][[2]]
covariances <- lapply(ellips, function(x){x[[1]]$covariance})
i = 1
mods <- lapply(1:ncol(config$layers), function(x){
normMods[which(1:nlayers(all.layers.norm) %in% config$layers[, x])]
})
mods
new.cents <- sapply(1:3, function(x){predict(mods[[x]], newdata = cent[x])})
mods[[1]]
library(raster); library(ntbox); library(doParallel); library(bestNormalize)
class(mods)
class(mods[[1]])
class(normMods[[1]])
class(normMods[[1]])
normMods[[1]]
#Normalising the layers in order to transform the original centroids
registerDoParallel(cores = 8)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
n <- bestNormalize(df)
df.t <- predict(n)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(list(normLayer = r, normMod = n))
}
all.layers.norm[[1]]
normMods <- sapply(all.layers.norm, function(x){x$normMod})
normMods
normMods[[1]]
length(all.layers.norm)
all.layers.norm[[1]]
class(all.layers.norm[[1]])
length(all.layers.norm[[1]])
all.layers.norm[[1]]$normMod
class(all.layers.norm[[1]]$normMod)
normMods <- lapply(all.layers.norm, function(x){x$normMod})
class(normMods[[1]])
all.layers.norm <- lapply(all.layers.norm, function(x){x$normLayer})
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
i
mods <- lapply(1:ncol(config$layers), function(x){
normMods[which(1:nlayers(all.layers.norm) %in% config$layers[, x])]
})
class(mods[[1]])
mods[[1]]
length(mods)
mods <- lapply(1:ncol(config$layers), function(x){
normMods[which(1:nlayers(spp.layers[[i]]) %in% config$layers[, x])]
})
length(mods)
1:nlayers(all.layers.norm)
which(1:nlayers(all.layers.norm) %in% config$layers[, x])
which(1:nlayers(all.layers.norm) %in% config$layers[, 1])
ids <- which(1:nlayers(all.layers.norm) %in% config$layers[, i])]
ids <- which(1:nlayers(all.layers.norm) %in% config$layers[, i])
mods <- normMods[ids]
mods
cent <- centroids[[i]]
new.cents <- sapply(1:3, function(x){predict(mods[[x]], newdata = cent[x])})
new.cents
cent
centroids.norm <- foreach(i = seq_along(centroids)) %dopar% {
ids <- which(1:nlayers(all.layers.norm) %in% config$layers[, i])
mods <- normMods[ids]
cent <- centroids[[i]]
new.cents <- sapply(1:3, function(x){predict(mods[[x]], newdata = cent[x])})
return(new.cents)
}
ellips[[1]][[1]]$centroid
centroids <- covariances <- lapply(ellips, function(x){x[[1]]$centroid})
centroids.norm <- foreach(i = seq_along(centroids)) %dopar% {
ids <- which(1:nlayers(all.layers.norm) %in% config$layers[, i])
mods <- normMods[ids]
cent <- centroids[[i]]
new.cents <- sapply(1:3, function(x){predict(mods[[x]], newdata = cent[x], inverse = T)})
return(new.cents)
}
centroids.norm.inv <- foreach(i = seq_along(centroids)) %dopar% {
ids <- which(1:nlayers(all.layers.norm) %in% config$layers[, i])
mods <- normMods[ids]
cent <- centroids[[i]]
new.cents <- sapply(1:3, function(x){predict(mods[[x]], newdata = cent[x], inverse = T)})
return(new.cents)
}
registerDoParallel(cores = 4)
corr.p.pres <- foreach(i = seq_along(ellips)) %dopar% {
cor.test(p.spp[[i]][], ellips[[i]][[2]]$suitRaster[])
}
dist.true.cents <- sapply(seq_along(ellips), function(x){
mahalanobis(centroids.norm.inv[[x]], spp.cent.cov$centroids[[x]], spp.cent.cov$covariances[[x]])
})
df.centroids <- data.frame(Corr.surf = corr.estimates, Dist.true.cent = dist.true.cents)
corr.estimates <- sapply(corr.p.pres, function(x){x$estimate})
dist.true.cents <- sapply(seq_along(ellips), function(x){
mahalanobis(centroids.norm.inv[[x]], spp.cent.cov$centroids[[x]], spp.cent.cov$covariances[[x]])
})
df.centroids <- data.frame(Corr.surf = corr.estimates, Dist.true.cent = dist.true.cents)
vars.spp <- foreach(i = seq_along(config$layer.names), .combine = rbind) %do% {
vars <- sapply(c("mean", "Log", "Beta", "Gamma"), function(x){
grep(pattern = x, config$layer.names[[i]])
})
return(sapply(vars, length))
}
vars.spp <- data.frame(vars.spp)
names(vars.spp) <- c("Normal", "Log.norm", "Beta", "Gamma")
df.results <- data.frame(df.centroids, vars.spp, approach = "Ellipses-NORM", centr.conf = "centre")
write.csv(df.results, "Simulated-species/Results-CentreEllipses-NORM.csv", row.names = F)
library(raster); library(doParallel)
library(raster); library(doParallel); library(bestNormalize)
l.sum <- read.csv("Simulated-layers/Layer-summaries.csv")
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- readRDS("Simulated-species/Sim-config-species-list.rds")
spp.layers <- lapply(1:ncol(config$layers), function(x){dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config$layers[, x])))})
spp.points <- readRDS("Simulated-species/Species-presences.rds")
p.spp <- readRDS("Simulated-species/P-presence.rds")
spp.cent.cov <- readRDS("Simulated-species/Spp-cent-covs.rds")
spp.ppms <- lapply(1:2500, function(x){
readRDS(paste0("../Resultados/Analysis-centroids/Fitted-Centre-Saturated-PPMs/PPM-", x, ".rds"))
})
spp.ppms <- lapply(1:2500, function(x){
readRDS(paste0("../Resultados/Analysis-centroids/Fitted-Centre-Saturated-PPMs-NORM/PPM-", x, ".rds"))
})
ppm.preds <- lapply(spp.ppms, function(x){x$pred})
cor.ppm.preds <- lapply(1:2500, function(x){cor.test(ppm.preds[[x]][], p.spp[[x]][])})
corr.estimates <- sapply(cor.ppm.preds, function(x){x$estimate})
centroids <- lapply(spp.ppms, function(x){
effects <- x$coef[2:7]
cent.a <- - effects[1]/(2 * effects[4])
cent.b <- - effects[2]/(2 * effects[5])
cent.c <- - effects[3]/(2 * effects[6])
centroid <- c(a = cent.a,
b = cent.b,
c = cent.c)
return(centroid)
})
registerDoParallel(cores = 8)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
n <- bestNormalize(df)
df.t <- predict(n)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(list(normLayer = r, normMod = n))
}
normMods <- lapply(all.layers.norm, function(x){x$normMod})
all.layers.norm <- lapply(all.layers.norm, function(x){x$normLayer})
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
#####
spp.layers <- lapply(1:ncol(config$layers), function(x){dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config$layers[, x])))})
centroids.norm.inv <- foreach(i = seq_along(centroids)) %dopar% {
ids <- which(1:nlayers(all.layers.norm) %in% config$layers[, i])
mods <- normMods[ids]
cent <- centroids[[i]]
new.cents <- sapply(1:3, function(x){predict(mods[[x]], newdata = cent[x], inverse = T)})
return(new.cents)
}
dist.true.cents <- sapply(seq_along(centroids), function(x){
mahalanobis(centroids.norm.inv[[x]], spp.cent.cov$centroids[[x]], spp.cent.cov$covariances[[x]])
})
df.centroids <- data.frame(Corr.surf = corr.estimates, Dist.true.cent = dist.true.cents)
vars.spp <- foreach(i = seq_along(config$layer.names), .combine = rbind) %do% {
vars <- sapply(c("mean", "Log", "Beta", "Gamma"), function(x){
grep(pattern = x, config$layer.names[[i]])
})
return(sapply(vars, length))
}
vars.spp <- data.frame(vars.spp)
names(vars.spp) <- c("Normal", "Log.norm", "Beta", "Gamma")
df.results <- data.frame(df.centroids, vars.spp, approach = "PPM-sat-NORM", centr.conf = "centre")
write.csv(df.results, "Simulated-species/Results-CentreSaturatedPPMs-NORM.csv", row.names = F)
#Analysis of models
ppms <- rbindlist(lapply(list.files("Simulated-species", "PPMs", full.names = T), read.csv))
library(data.table); library(doParallel); library(reshape)
library(raster); library(ggplot2)
#Analysis of models
ppms <- rbindlist(lapply(list.files("Simulated-species", "PPMs", full.names = T), read.csv))
ellips <-  rbindlist(lapply(list.files("Simulated-species", "llipses", full.names = T), read.csv))
all.results <- rbind(ppms, ellips)
#Model subsets
ppms.sat <- subset(ppms, approach == c("PPM-sat", "PPM-sat-NORM"))
ppms.step <- subset(ppms, approach == "PPM-step")
corr.dif.sat <- ppms.sat$Corr.surf - ellips$Corr.surf
dist.dif.sat <- ellips$Dist.true.cent - ppms.sat$Dist.true.cent
#Environmental layers
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids",), ".rds"), readRDS)
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
library(foreach)
bimod <- lapply(1:nlayers(all.layers), function(x){diptest::dip.test(all.layers[[x]][])})
#Environmental layers
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
all.layers.norm <- readRDS("Simulated-layers/All-simulated-layers-NORM.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
bimod <- lapply(1:nlayers(all.layers), function(x){diptest::dip.test(all.layers[[x]][])})
bimod.norm <- lapply(1:nlayers(all.layers.norm), function(x){diptest::dip.test(all.layers.norm[[x]][])})
spp.layers <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config[[1]]$layers[, k])))
}
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
comp.bimod <- foreach(k = 1:ncol(config[[1]]$layers), .combine = c) %do% {
b <- bimod[c(which(1:nlayers(all.layers) %in% config[[1]]$layers[, k]))]
sum(sapply(b, function(x){x$statistic}))
}
comp.bimod.norm <- foreach(k = 1:ncol(config[[1]]$layers), .combine = c) %do% {
b <- bimod.norm[c(which(1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k]))]
sum(sapply(b, function(x){x$statistic}))
}
pres <- lapply(paste0("Simulated-species/Species-presences",
c(".rds",
"-EdgeCentroids.rds",
"-OuterCentroids.rds",
"-RandomCentroids.rds")), readRDS)
#Skewness analyses
registerDoParallel(cores = 4)
s <- seq(1, 10000, by = 10) #Sample of the environment
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
env.skew.norm <- foreach(i = seq_along(spp.layers.norm), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
head(ppms.sat)
head(ellips)
#Adding the analyses to model data
ppms.sat$Skewness.env <- c(rep(env.skew.norm, 4), rep(env.skew, 4))
ppms.step$Skewness.env <- rep(env.skew, 4)
nrow(ppms.sat)
tail(ppms.sat)
ppms.sat$approach
nrow(ppms.step)
list.files("Simulated-species", "PPMs", full.names = T)
nrow(ppms)
#Model subsets
ppms.sat <- subset(ppms, approach == c("PPM-sat" | "PPM-sat-NORM"))
#Model subsets
ppms.sat <- subset(ppms, approach == "PPM-sat")
ppms.sat.norm <- subset(ppms, approach == "PPM-sat-NORM")
list.files("Simulated-species", "llipses", full.names = T)
ellips <-  rbindlist(lapply(list.files("Simulated-species", "llipses", full.names = T), read.csv))
head(ellips)
corr.dif.sat <- ppms.sat$Corr.surf - ellips$Corr.surf
dist.dif.sat <- ellips$Dist.true.cent - ppms.sat$Dist.true.cent
#Environmental layers
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
all.layers.norm <- readRDS("Simulated-layers/All-simulated-layers-NORM.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
library(foreach)
bimod <- lapply(1:nlayers(all.layers), function(x){diptest::dip.test(all.layers[[x]][])})
bimod.norm <- lapply(1:nlayers(all.layers.norm), function(x){diptest::dip.test(all.layers.norm[[x]][])})
spp.layers <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config[[1]]$layers[, k])))
}
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
pres <- lapply(paste0("Simulated-species/Species-presences",
c(".rds",
"-EdgeCentroids.rds",
"-OuterCentroids.rds",
"-RandomCentroids.rds")), readRDS)
#Adding the analyses to model data
ppms.sat$Skewness.env <- rep(env.skew, 4)
ppms.sat.norm$Skewness.env <- rep(env.skew, 4)
ppms.sat.norm$Skewness.env <- rep(env.skew.norm, 4)
ellips$Skewness.env <-  rep(env.skew, 4)
ellips <- subset(ellips, approach = "Ellipses")
nrow(ellips)
nrow(ellips.norm)
ellips <-  rbindlist(lapply(list.files("Simulated-species", "llipses", full.names = T), read.csv))
all.results <- rbind(ppms, ellips)
#Model subsets
ppms.sat <- subset(ppms, approach == "PPM-sat")
ppms.sat.norm <- subset(ppms, approach == "PPM-sat-NORM")
ppms.step <- subset(ppms, approach == "PPM-step")
ellips.norm <- subset(ellips, approach = "Ellipses-NORM")
ellips <- subset(ellips, approach = "Ellipses")
nrow(ellips.norm)
lapply(list.files("Simulated-species", "llipses", full.names = T)
levels(ellips$approach)
ellips.norm <- subset(ellips, approach = "Ellipses-NORM")
levels(ellips.norm$approach)
ellips.norm <- subset(ellips, approach == "Ellipses-NORM")
ellips <- subset(ellips, approach == "Ellipses")
ellips$Skewness.env <-  rep(env.skew, 4)
ellips.norm$Skewness.env <-  c(rep(env.skew.norm, 4), rep(env.skew, 4))
ellips.norm$Skewness.env <-  rep(env.skew.norm, 4)
ellips$bimod <- c(rep(comp.bimod.norm, 4), rep(comp.bimod, 4))
ellips.norm$bimod <- rep(comp.bimod.norm, 4)
dat.skew <- rbind(ppms.sat, ppms.sat.norm, ellips, ellips.norm)
library(data.table); library(doParallel); library(reshape)
library(raster); library(ggplot2)
#Analysis of models
ppms <- rbindlist(lapply(list.files("Simulated-species", "PPMs", full.names = T), read.csv))
ellips <-  rbindlist(lapply(list.files("Simulated-species", "llipses", full.names = T), read.csv))
all.results <- rbind(ppms, ellips)
#Model subsets
ppms.sat <- subset(ppms, approach == "PPM-sat")
ppms.sat.norm <- subset(ppms, approach == "PPM-sat-NORM")
ppms.step <- subset(ppms, approach == "PPM-step")
ellips.norm <- subset(ellips, approach == "Ellipses-NORM")
ellips <- subset(ellips, approach == "Ellipses")
corr.dif.sat <- ppms.sat$Corr.surf - ellips$Corr.surf
dist.dif.sat <- ellips$Dist.true.cent - ppms.sat$Dist.true.cent
#Environmental layers
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
all.layers.norm <- readRDS("Simulated-layers/All-simulated-layers-NORM.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
library(foreach)
bimod <- lapply(1:nlayers(all.layers), function(x){diptest::dip.test(all.layers[[x]][])})
bimod.norm <- lapply(1:nlayers(all.layers.norm), function(x){diptest::dip.test(all.layers.norm[[x]][])})
spp.layers <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config[[1]]$layers[, k])))
}
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
comp.bimod <- foreach(k = 1:ncol(config[[1]]$layers), .combine = c) %do% {
b <- bimod[c(which(1:nlayers(all.layers) %in% config[[1]]$layers[, k]))]
sum(sapply(b, function(x){x$statistic}))
}
comp.bimod.norm <- foreach(k = 1:ncol(config[[1]]$layers), .combine = c) %do% {
b <- bimod.norm[c(which(1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k]))]
sum(sapply(b, function(x){x$statistic}))
}
pres <- lapply(paste0("Simulated-species/Species-presences",
c(".rds",
"-EdgeCentroids.rds",
"-OuterCentroids.rds",
"-RandomCentroids.rds")), readRDS)
#Skewness analyses
registerDoParallel(cores = 4)
s <- seq(1, 10000, by = 10) #Sample of the environment
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
env.skew.norm <- foreach(i = seq_along(spp.layers.norm), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
#Adding the analyses to model data
ppms.sat$Skewness.env <- rep(env.skew, 4)
ppms.sat.norm$Skewness.env <- rep(env.skew.norm, 4)
ppms.step$Skewness.env <- rep(env.skew, 4)
ellips$Skewness.env <-  rep(env.skew, 4)
ellips.norm$Skewness.env <-  rep(env.skew.norm, 4)
ppms.sat$bimod <-rep(comp.bimod, 4)
ppms.sat.norm$bimod <- rep(comp.bimod.norm, 4)
ppms.step$bimod <- rep(comp.bimod, 4)
ellips$bimod <- rep(comp.bimod, 4)
ellips.norm$bimod <- rep(comp.bimod.norm, 4)
dat.skew <- rbind(ppms.sat, ppms.sat.norm, ellips, ellips.norm)
ggplot(dat.skew) + geom_hex(aes(x = Skewness.env, y = log10(Dist.true.cent))) +
scale_fill_continuous(type = "viridis", trans = "log10") +
geom_smooth(aes(x = Skewness.env, y = log10(Dist.true.cent)), colour = "red", alpha = 0.5) +
labs(fill = expression(paste(log[10], " count")), colour = "",
x = "Multivariate environmental skewness",
y = expression(paste(log[10], " Distance to true centroid"))) +
facet_grid(rows = vars(approach), cols = vars(centr.conf))
dat.skew <- rbind(ppms.sat, ellips)
dat.skew.norm <- rbind(ppms.sat.norm, ellips.norm)
ggplot(dat.skew) + geom_hex(aes(x = Skewness.env, y = log10(Dist.true.cent))) +
scale_fill_continuous(type = "viridis", trans = "log10") +
geom_smooth(aes(x = Skewness.env, y = log10(Dist.true.cent)), colour = "red", alpha = 0.5) +
labs(fill = expression(paste(log[10], " count")), colour = "",
x = "Multivariate environmental skewness",
y = expression(paste(log[10], " Distance to true centroid"))) +
facet_grid(rows = vars(approach), cols = vars(centr.conf))
ggplot(dat.skew.norm) + geom_hex(aes(x = Skewness.env, y = log10(Dist.true.cent))) +
scale_fill_continuous(type = "viridis", trans = "log10") +
geom_smooth(aes(x = Skewness.env, y = log10(Dist.true.cent)), colour = "red", alpha = 0.5) +
labs(fill = expression(paste(log[10], " count")), colour = "",
x = "Multivariate environmental skewness",
y = expression(paste(log[10], " Distance to true centroid"))) +
facet_grid(rows = vars(approach), cols = vars(centr.conf))
ggplot(dat.skew) + geom_hex(aes(x = Skewness.env, y = Corr.surf)) +
scale_fill_continuous(type = "viridis", trans = "log10") +
geom_smooth(aes(x = Skewness.env, y = Corr.surf),  colour = "red", alpha = 0.5) +
labs(fill = expression(paste(log[10], " count")), colour = "",
x = "Multivariate environmental skewness",
y = "Correlation with generating surface") +
facet_grid(rows = vars(approach), cols = vars(centr.conf))
ggplot(dat.skew.norm) + geom_hex(aes(x = Skewness.env, y = Corr.surf)) +
scale_fill_continuous(type = "viridis", trans = "log10") +
geom_smooth(aes(x = Skewness.env, y = Corr.surf),  colour = "red", alpha = 0.5) +
labs(fill = expression(paste(log[10], " count")), colour = "",
x = "Multivariate environmental skewness",
y = "Correlation with generating surface") +
facet_grid(rows = vars(approach), cols = vars(centr.conf))
dat.skew.all <- rbind(dat.skew, dat.skew.norm)
ggplot(dat.skew.all) + geom_hex(aes(x = Skewness.env, y = Corr.surf)) +
scale_fill_continuous(type = "viridis", trans = "log10") +
geom_smooth(aes(x = Skewness.env, y = Corr.surf),  colour = "red", alpha = 0.5) +
labs(fill = expression(paste(log[10], " count")), colour = "",
x = "Multivariate environmental skewness",
y = "Correlation with generating surface") +
facet_grid(rows = vars(approach), cols = vars(centr.conf))
