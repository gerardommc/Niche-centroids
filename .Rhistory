abline(v = mean(log(x)[]), col = "red")
plot(x.norm.r)
density(x.norm.r)
abline(v = mean(x.norm.r[]), col = "red")
x <- all.layers[["Gamma.1.1"]]
x.df <- x[]
class(x.df) <- "non"
x.norm <- normalise(x.df)
x.norm.r <- x
x.norm.r[] <- x.norm
par(mfrow = c(3,2))
plot(x)
density(x)
abline(v = mean(x[]), col = "red")
plot(log(x))
density(log(x))
abline(v = mean(log(x)[]), col = "red")
plot(x.norm.r)
density(x.norm.r)
abline(v = mean(x.norm.r[]), col = "red")
library(MVN); library(doParallel); library(raster)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
spp.layers <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config[[1]]$layers[, k])))
}
source("Normalise-functions.R")
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = seq_along(all.layers)) %dopar% {
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist[x]
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
return(r)
}
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = seq_along(all.layers)) %dopar% {
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
return(r)
}
warnings()
i = 1
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
plot(r)
plot(all.layers[[i]])
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
var.dist
class(df) <- var.dist
df.t <- normalise(df)
i = 41
df <- all.layers[[i]][]
seq_along(all.layers)
nlayers(all.layers)
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
return(r)
}
i = 1
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
dim(r)
length(df.t)
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- df.t
i = 41
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
var.dist
class(df) <- var.dist
df.t <- normalise(df)
plot(all.layers[[41]])
density(all.layers[[41]])
names(all.layers)
i = 42
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
plot(log(all.layers[[41]]))
density(log(all.layers[[41]]))
x
df <- as.matrix(all.layers[[i]])
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
var.dist
class(df) <- var.dist
df.t <- normalise(df)
x <- df
tra <- sapply(seq(-2, 2, by = 0.25), function(x1){ car :: bcPower(x, lambda = x1, gamma = abs(min(x)) + 0.01)})
bcPower(x, lambda = -2, gamma = abs(min(x)) + 0.01)
car::bcPower(x, lambda = -2, gamma = abs(min(x)) + 0.01)
car::bcPower(x, lambda = -1, gamma = abs(min(x)) + 0.01)
car::bcPower(x, lambda = 1.5, gamma = abs(min(x)) + 0.01)
abs(min(x))
min(x)
abs(min(x)) + 0.01
car::yjPower(x, lambda = 1.5)
ncol(x)
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100)
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100)
return(r)
}
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 4)
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
library(MVN); library(doParallel); library(raster)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
spp.layers <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config[[1]]$layers[, k])))
}
source("Normalise-functions.R")
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100)
return(r)
}
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 4)
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 4)
env.skew.norm <- foreach(i = seq_along(spp.layers.norm), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
env.skew.norm <- env.skew
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
df.sk <- data.frame(sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected", each = 2500)))
length(env.skew.norm)
length(env.skew)
df.sk <- data.frame(sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected"), each = 2500))
library(ggplot)
library(ggplot2)
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk))
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100)
return(r)
}
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 4)
env.skew.norm <- foreach(i = seq_along(spp.layers.norm), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
df.sk <- data.frame(sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected"), each = 2500))
library(ggplot2)
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk))
for(i in 1:100){
par(mfrow = c(2,2))
plot(all.layers[[i]], main = "Uncorrected")
density(all.layers[[i]])
plot(all.layers.norm[[i]], main = "Corrected")
density(all.layers.norm[[i]])
}
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(r)
}
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
for(i in 1:100){
par(mfrow = c(2,2))
plot(all.layers[[i]], main = "Uncorrected")
density(all.layers[[i]])
plot(all.layers.norm[[i]], main = "Corrected")
density(all.layers.norm[[i]])
}
saveRDS(all.layers.norm, "Simulated-layers/All-simulated-layers-NORM.rds")
tra
source("Normalise-functions.R")
source("Normalise-functions.R")
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df, precision = 0.1)
r <- all.layers[[i]]
r[] <- matrix(df.t[[1]], 100, 100, byrow = T)
return(list(r, lambda = df.t$lambda, gamma = df.t$gamma))
}
source("Normalise-functions.R")
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df, precision = 0.1)
r <- all.layers[[i]]
r[] <- matrix(df.t[[1]], 100, 100, byrow = T)
return(list(r, lambda = df.t$lambda, gamma = df.t$gamma))
}
source("Normalise-functions.R")
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df, precision = 0.1)
r <- all.layers[[i]]
r[] <- matrix(df.t[[1]], 100, 100, byrow = T)
return(list(r, lambda = df.t$lambda, gamma = df.t$gamma))
}
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t[[1]], 100, 100, byrow = T)
return(list(r, lambda = df.t$lambda, gamma = df.t$gamma))
}
all.layers.norm[[1]]
lambdas <- sapply(all.layers.norm, function(x){x$lambda})
gammas <- sapply(all.layers.norm, function(x){x$gamma})
lambdas
gammas
all.layers.norm <- lapply(all.layers.norm, function(x){x[[1]]})
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
saveRDS(all.layers.norm, "Simulated-layers/All-simulated-layers-NORM.rds")
normalise.non <- function(x){
gamma <- abs(min(x)) + 0.01
lambda <- seq(-2, 2, by = 0.01)
tra <- sapply(lambda, function(x1){ car :: bcPower(x, lambda = x1, gamma = gamma)})
sk <- MultiSkew::FisherSkew(tra)
return(list(tra[, which.min(abs(sk[2, ]))],
lambda = lambda[which.min(abs(sk[2, ]))],
gamma = gamma))
}
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
df.t <- normalise(df)
r <- all.layers[[i]]
r[] <- matrix(df.t[[1]], 100, 100, byrow = T)
return(list(r, lambda = df.t$lambda, gamma = df.t$gamma))
}
lambdas <- sapply(all.layers.norm, function(x){x$lambda})
gammas <- sapply(all.layers.norm, function(x){x$gamma})
lambdas
lambdas <- sapply(all.layers.norm, function(x){x$lambda})
gammas <- sapply(all.layers.norm, function(x){x$gamma})
all.layers.norm <- lapply(all.layers.norm, function(x){x[[1]]})
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
saveRDS(all.layers.norm, "Simulated-layers/All-simulated-layers-NORM.rds")
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 4)
env.skew.norm <- foreach(i = seq_along(spp.layers.norm), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
df.sk <- data.frame(sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected"), each = 2500))
library(ggplot2)
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk))
for(i in 1:100){
par(mfrow = c(2,2))
plot(all.layers[[i]], main = "Uncorrected")
density(all.layers[[i]])
plot(all.layers.norm[[i]], main = "Corrected")
density(all.layers.norm[[i]])
}
install.packages("bestNormalize")
names(all.layers)
i = 81
plot(all.layers[[81]])
densiy(all.layers[[81]])
density(all.layers[[81]])
density(all.layers[[91]])
density(all.layers[[95]])
for(i in 81:100){
par(mfrow = c(2,2))
plot(all.layers[[i]], main = "Uncorrected")
density(all.layers[[i]])
plot(all.layers.norm[[i]], main = "Corrected")
density(all.layers.norm[[i]])
}
for(i in 81:100){
par(mfrow = c(2,2))
plot(all.layers[[i]], main = i)
density(all.layers[[i]])
plot(all.layers.norm[[i]], main = "Corrected")
density(all.layers.norm[[i]])
}
i = 82
df <- all.layers[[i]][]
library(bestNormalize)
df.t <- bestNormalize(df)
plot(density(df.t))
df.t
plot(density(predict(df.t)))
plot(density(df))
system.time(
df.t <- bestNormalize(df)
)
system.time(
norms <- bestNormalize(df)
df.t <- predict(norms)
)
system.time(
norms <- bestNormalize(df);
df.t <- predict(norms)
)
system.time({
norms <- bestNormalize(df)
df.t <- predict(norms)})
library(MVN); library(doParallel); library(raster); library(bestNormalize)
all.layers <- readRDS("Simulated-layers/All-simulated-layers.rds")
config <- lapply(paste0("Simulated-species/Sim-config-species-list",
c("", "-EdgeCentroids",
"-OuterCentroids",
"-RandomCentroids"), ".rds"), readRDS)
spp.layers <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers, i = c(which(! 1:nlayers(all.layers) %in% config[[1]]$layers[, k])))
}
registerDoParallel(cores = 4)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
n <- bestNormalize(df)
df.t <- predict(n)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(list(normLayer = n, normMod = n))
}
normMods <- sapply(all.layers.norm, function(x){x$normMod})
all.layers.norm <- lapply(all.layers.norm, function(x){x$normLayer})
all.layers.norm <- stack(all.layers.norm)
all.layers.norm[[1]]
registerDoParallel(cores = 8)
all.layers.norm <- foreach(i = 1:nlayers(all.layers)) %dopar% {
df <- all.layers[[i]][]
var.dist <- ifelse(grepl("mean", names(all.layers)[i]), "norm", "non")
class(df) <- var.dist
n <- bestNormalize(df)
df.t <- predict(n)
r <- all.layers[[i]]
r[] <- matrix(df.t, 100, 100, byrow = T)
return(list(normLayer = r, normMod = n))
}
normMods <- sapply(all.layers.norm, function(x){x$normMod})
all.layers.norm <- lapply(all.layers.norm, function(x){x$normLayer})
all.layers.norm <- stack(all.layers.norm)
names(all.layers.norm) <- names(all.layers)
saveRDS(all.layers.norm, "Simulated-layers/All-simulated-layers-NORM.rds")
spp.layers.norm <- foreach(k = 1:ncol(config[[1]]$layers)) %do% {
dropLayer(all.layers.norm, i = c(which(! 1:nlayers(all.layers.norm) %in% config[[1]]$layers[, k])))
}
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 4)
registerDoParallel(cores = 4)
length(s)
## Measuring skewness of transformed variables
s <- seq(1, 10000, by = 10)
length(s)
env.skew.norm <- foreach(i = seq_along(spp.layers.norm), .combine = c) %dopar% {
df <- as.matrix(spp.layers.norm[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
env.skew <- foreach(i = seq_along(spp.layers), .combine = c) %dopar% {
df <- as.matrix(spp.layers[[i]])[s, ]
res <- MVN::mvn(df, mvnTest = "hz", multivariatePlot = F)$multivariateNormality$HZ
return(res)
}
df.sk <- data.frame(sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected"), each = 2500))
library(ggplot2)
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk))
for(i in 1:100){
par(mfrow = c(2,2))
plot(all.layers[[i]], main = i)
density(all.layers[[i]])
plot(all.layers.norm[[i]], main = "Corrected")
density(all.layers.norm[[i]])
}
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk))
paired.t.test(env.skew, env.skew.norm)
t.test(env.skew, env.skew.norm, paired = T)
length(which((env.skew - env.skew.norm) > 0))
length(which((env.skew - env.skew.norm) < 0))
env.skew - env.skew.norm
length(which((env.skew.norm - env.skew) < 0))
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk)) +
geom_point(aes(x = type, y = sk), alpha = 0.5, colour = "red")
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk)) +
geom_point(aes(x = type, y = sk), alpha = 0.1, colour = "red")
write.csv(df.sk, "Simulated-layers/Skewness-difference-NORM-DATA.csv")
df.sk <- data.frame(set = rep(1:2500, 2), sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected"), each = 2500))
df.sk <- data.frame(set = rep(1:2500, 2), sk = c(env.skew.norm, env.skew), type = rep(c("Corrected", "Uncorrected"), each = 2500))
write.csv(df.sk, "Simulated-layers/Skewness-difference-NORM-DATA.csv")
saveRDS(normMods, "Simulated-layers/Normalising-models.rds")
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk)) +
labs(x = "Variables", y = "Multivariate skewness")
pdf("../Graphs/Skewness-Corr-Uncorr.pdf", width = 4, height = 4)
ggplot(df.sk) + geom_boxplot(aes(x = type, y = sk)) +
labs(x = "Variables", y = "Multivariate skewness")
dev.off()
